---
layout: post
title: "에이전트 리더보드: 다중 도메인 시나리오에서의 AI 에이전트 평가"
author: jimin
categories: [Agent]
image: assets/images/blog/posts/2025-11-17-agent-leaderboard/thumbnail.png
---

* TOC
{:toc}
<!--toc-->

_이 글은 Hugging Face 블로그의 [Agent 
Leaderboard: Evaluating AI Agents in Multi-Domain Scenarios](https://huggingface.co/blog/pratikbhavsar/agent-leaderboard)를 한국어로 번역한 글입니다._

---

# 에이전트 리더보드: 다중 도메인 시나리오에서의 AI 에이전트 평가

젠슨 황(Jensen Huang)은 AI 에이전트를 “디지털 노동력(digital workforce)”이라고 불렀습니다. 이러한 의견은 그만의 생각이 아닙니다. 사티아 나델라(Satya Nadella) 역시 에이전트가 비즈니스 운영 방식을 근본적으로 바꿀 것이라고 믿고 있습니다.  

이러한 에이전트들은 외부 도구 및 API와 상호작용할 수 있어, 실질적인 응용 가능성을 크게 확장합니다. 그러나 여전히 완벽가는 거리가 멀며, 복잡한 상호작용 때문에 에이전트들의 성능을 평가하는 일은 어렵습니다.  

우리의 **에이전트 리더보드(Agent Leaderboard)**는 Galileo의 **도구 선택 품질 지표(tool selection quality metric)**를 사용해 다면적으로 LLM들이 도구 기반 상호작용을 어떻게 처리하는지 명확히 평가합니다.  

우리가 이 리더보드를 만든 이유는 단순합니다:  **“AI 에이전트는 실제 비즈니스 시나리오에서 얼마나 잘 작동하는가?”**  
학술적 벤치마크가 기술적 역량을 알려준다면, 우리는 다양한 실제 사용 사례에서 어떤 모델이 유용한지를 알고자 합니다.  

---

## 기존 에이전트 평가 리더보드와의 차별점은? 🎯

[huggingface.co/spaces/galileo-ai/agent-leaderboard](https://huggingface.co/spaces/galileo-ai/agent-leaderboard)

기존 평가 프레임워크들은 특정 영역에 집중되어 있습니다. **BFCL**은 수학·엔터테인먼트·교육 등 학술 영역에 강하고, **τ-bench**는 소매 및 항공 시나리오에 특화되어 있으며, **xLAM**은 21개 도메인에 걸친 데이터 생성에 초점을 맞춥니다. **ToolACE**는 390개 도메인에서의 API 상호작용에 중점을 둡니다. 우리의 리더보드는 이러한 데이터셋들을 통합해 **다중 도메인 및 실제 사용 사례를 포괄하는 종합 평가 프레임워크**를 제공합니다.  

우리는 다양한 벤치마크와 테스트 시나리오를 통합하여 모델들이 **엣지 케이스와 안전성**을 어떻게 다루는지에 대한 실질적인 통찰을 제공합니다. 또한 **비용 효율성**, **구현 가이드라인**, **비즈니스 영향력** 등을 분석하여 실제 조직에서 AI 에이전트를 배포할 때 필수적인 정보를 제공합니다. 즉, 각 팀이 자신들의 에이전트 요구사항과 제약 조건에 가장 적합한 모델을 선택할 수 있도록 돕는 리더보드입니다.  

새로운 LLM들이 매우 자주 출시되므로, 우리는 매달 벤치마크를 업데이트하여 최신 모델 출시와 동기화할 예정입니다.  


## 핵심 인사이트 💡

우리가 분석한 17개의 주요 LLM은 실제 업무 과제에서 에이전트가 어떻게 작동하는지 흥미로운 패턴을 보여주었습니다. 우리는 14개 다양한 벤치마크를 기반으로, 간단한 API 호출부터 복잡한 다중 도구에 대한 상호작용까지 폭넓게 강도높은 테스트를 수행했습니다.  

그 결과는 기존의 모델 성능에 대한 통념을 깨고, AI 에이전트를 구축하는 팀들에게 실질적인 인사이트를 제공할 수 있습니다.


## 도구 호출의 복잡성 ⚙️

도구 호출의 복잡성은 이제 단순한 API 호출 수준을 훨씬 넘어섰습니다. 다양한 시나리오에서 AI 에이전트는 도구를 언제 사용할지, 어떤 도구가 적합한지, 어떻게 사용해야할지 올바르게 판단해야 합니다.

이를 정교하게 평가하기 위해, 도구 호출 과정에서 고려해야할 핵심 요소를 네 가지로 살펴볼 수 있습니다: 시나리오 인식(Scenario Recognition), 도구 선택의 역학(Tool Selection Dynamics), 매개변수 처리(Parameter Handling), 순차적 의사결정(Sequential Decision Making)


| 항목                                        | 요약                                   | 상세                                                                                                                                           |
| ----------------------------------------- | --------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **시나리오 인식**        | 먼저 “도구를 써야 하는가?”를 판단해야 함                | - 대화 기록에 이미 필요한 정보가 있을 수 있음 → 도구 호출이 **불필요**할 수 있음<br>- 반대로, 사용할 수 있는 도구가 문제 해결에 **부적절하거나 부족**할 수도 있음<br>- 이런 경우, 억지로 도구를 쓰기보다 **제한을 인식하고 사용자에게 명확히 설명**해야 함   |
| **도구 선택의 역학**   | 도구 선택은 ‘맞다/틀리다’가 아니라 **정밀도와 재현율**의 문제   | - 필요한 도구 중 일부만 선택 → **재현율 문제**(필요한 것을 놓침)<br>- 필요한 도구는 골랐지만 불필요한 도구까지 함께 선택 → **정밀도 문제**(쓸데없는 것까지 포함)<br>- 둘 다 오류이지만 **발생 원인과 심각도는 서로 다름**                     |
| **매개변수 처리**          | 도구는 올바른 인자(argument)를 제공해야 실제로 작동함      | - 필요한 **모든 필수 매개변수**를 정확한 이름으로 제공해야 함<br>- 선택적(optional) 파라미터는 적절히 포함하거나 생략해야 함<br>- 각 값은 **정확한 의미를 반영**해야 함<br>- 제공 형식은 **도구 사양에 맞게** 구성해야 함                  |
| **순차적 의사결정 (Sequential Decision Making)** | 여러 단계가 필요한 작업에서는 도구 호출 순서·의존성을 잘 관리해야 함 | - 어떤 도구를 먼저 호출할지 **최적 순서를 결정**해야 함<br>- 각 도구 호출이 다른 호출 결과에 **의존**할 수 있음<br>- 여러 단계 작업에서 전체 **컨텍스트를 유지**해야 함<br>- 중간에 실패가 생기면 **상황에 맞춰 적응**해야 함(다시 시도, 경로 변경 등) |


이러한 복잡성 때문에 도구 선택 품질(Tool Selection Quality, 이하 TSQ)은 단순한 지표가 아니라, 실제 시나리오에서 에이전트의 의사결정 능력을 다면적으로 평가하는 척도입니다.


## 방법론 🔍

우리의 평가 프로세스는 AI 에이전트를 공정하고 체계적으로 평가하기 위해 다음과 같은 단계를 따릅니다.

1. **모델 선정 (Model Selection)**: 상용 및 오픈소스 모델을 포함해 다양한 언어 모델을 선정합니다. 이를 통해 현존 기술의 폭넓은 스펙트럼을 반영합니다.

2. **에이전트 구성 (Agent Configuration)**: 각 모델을 표준화된 시스템 프롬프트를 사용해 에이전트로 구성하고, 동일한 도구 세트에 접근할 수 있도록 설정합니다. 이러한 표준화는 성능 차이가 프롬프트 설계의 차이가 아닌, 모델 고유의 능력을 반영하게 됩니다.

3. **평가 지표 정의 (Metric Definition)**: 도구 선택의 정확성과 매개변수 사용의 질을 모두 평가하는 **도구 선택 품질(TSQ)**을 주요 지표로 설정합니다. 이 지표는 실제 환경에서 요구되는 성능을 포착하도록 신중하게 설계되었습니다.

4. **데이터셋 구성 (Dataset Curation)**: 기존 벤치마크 데이터셋을 전략적으로 샘플링하여 균형 잡히고, 다중 도메인을 아우르는 평가용 데이터셋을 만들빈다. 이 데이터셋은 기본 함수 호출부터 복잡한 다중 턴 상호작용까지 모두 테스트할 수 있어 에이전트 능력을 포괄적으로 평가합니다.

5. **점수 체계 (Scoring System)**: 최종 성능 점수는 모든 데이터셋에 대해 동일한 가중치로 산출한 평균을 계산합니다. 이를 통해 특정 능력 하나가 전체 평가를 좌우하지 않으며, 에이전트 성능을 균형있게 보여줄 수 있습니다.

이와 같은 구조화된 접근 방식을 통해, 우리는 평가 결과를 실제 구현 의사결정에 직접 적용할 수 있는 통찰을 제공합니다.



## 에이전트 성능은 어떻게 측정하나? 📊


### 평가 방식: TSQ 지표를 통한 LLM-Judge 활용

앞서 본 것처럼, 도구 호출 평가는 다양한 시나리오에서의 견고한 측정이 필요합니다. 우리는 **도구 선택 품질(TSQ)** 지표를 통해, 에이전트의 **도구 선택 정확도**와 **매개변수 활용 효율성**을 평가했습니다.  
이 프레임워크는 에이전트의 도구 사용이 적절한지, 불필요한 도구 사용은 없는지를 모두 검증합니다.  

평가는 **GPT-4o + [ChainPoll](https://arxiv.org/abs/2310.18344)**을 사용하여 수행됩니다. 각 상호작용마다 여러 개의 독립적인 판단이 수집되며, 최종 점수는 **긍정적 평가 비율**로 계산됩니다. 모든 판단에는 상세한 설명이 포함되어 투명성을 확보합니다.  
*ChainPoll: LLM의 판단을 여러 번 묻고(reasoning 포함) 결과를 집계하여 신뢰도 높은 평가 점수를 만드는 방법. 

#### 1. 데이터 로드
- 평가할 대화 데이터를 Parquet 파일에서 읽음
- df의 각 row에는 아마 사용자 메시지, 시스템 메시지 등 대화 기록(conversation)이 들어 있을 것
```python
df = pd.read_parquet(file_path, engine="fastparquet")
```

#### 2. ChainPoll scorer 설정
- 각 도구 선택이 적절했는지 판단하고, reasoning을 포함한 ChainPoll 점수를 산출하도록 설정
- `CustomizedChainPollScorer`: ChainPoll 방식을 이용한 커스텀 scorer
- 평가 항목: `tool_selection_quality` → LLM이 선택한 도구가 적절했는지 평가
- Judge 모델: GPT‑4o 사용
```python
chainpoll_tool_selection_scorer = pq.CustomizedChainPollScorer(
                scorer_name=pq.CustomizedScorerName.tool_selection_quality,
                model_alias=pq.Models.gpt_4o,
            )
```

#### 3.  평가 핸들러 설정
- `GalileoPromptCallback`: 평가 과정에서 ChainPoll 점수를 기록하고 관리
- scorers 리스트에 ChainPoll scorer를 넣어 LLM이 도구 선택 시 평가하도록 함

```python
evaluate_handler = pq.GalileoPromptCallback(
        project_name=project_name,
        run_name=run_name,
        scorers=[chainpoll_tool_selection_scorer],
    )
```

#### 4.  LLM 초기화
- 평가에 사용할 LLM을 초기화
- `temperature=0.0` → deterministic (같은 입력에 항상 같은 출력)
- `max_tokens=4000` → 응답 최대 길이

```python
llm = llm_handler.get_llm(model, temperature=0.0, max_tokens=4000)
```

#### 5. 시스템 메시지 정의
- LLM에게 도구 사용 규칙과 대화 지침을 제공
- “도구가 없으면 대답 불가”, “필요 시 추가 정보 요청”, “순차 호출 시 첫 번째 도구부터 호출” 등의 규칙 포함
```python
system_msg = {
    "role": "system",
    "content": (
        "당신의 임무는 주어진 도구를 사용해 사용자의 질문에 답하는 것입니다. "
        "관련 도구가 없으면 '주어진 도구로는 대답할 수 없습니다.'라고 응답하세요. "
        "필요한 정보가 부족하면 사용자에게 요청하세요. "
        "필요한 경우 여러 도구를 호출할 수 있습니다. 순차 호출이 필요하면 첫 번째 도구부터 호출하세요."
    ),
}
```

#### 6. 대화별 LLM 실행 및 평가
- `bind_tools(tools)` → LLM에 도구 접근 권한 바인딩
- `chain.invoke([...])` → 시스템 메시지 + 대화 내역을 LLM에 입력, 출력 생성
- `callbacks=[evaluate_handler]` → ChainPoll scorer가 실시간 평가 수행
- LLM 응답과 ChainPoll 평가 결과를 `outputs`에 저장

```python
outputs = []

for row in df.itertuples():
    chain = llm.bind_tools(tools)
    outputs.append(
        chain.invoke(
            [system_msg, *row.conversation], 
            config=dict(callbacks=[evaluate_handler])
        )
    )
```

#### 7.  평가 종료

- 모든 대화 평가가 끝난 후 점수 정리 및 로그 저장

```python
evaluate_handler.finish()
```

### 왜 도구 호출 평가에 LLM이 필요한가?

LLM 기반 평가(LLM-Judge)는 다양한 시나리오에서 에이전트의 도구 사용 능력을 종합적으로 검증할 수 있습니다. 
- 맥락 부족 상황: 에이전트가 맥락 부족 상황을 적절히 처리하는지 확인. 도구 사용 전에 추가 정보가 필요한지 판단하고, 필요 시 추가 정보 요청 여부 검증
- 다중 도구 시나리오 상황: 필요한 모든 도구가 식별되고 올바른 순서로 사용되는지 확인
- 긴 대화 맥락 상황: 이전 대화에서 나온 관련 정보를 고려하는지 확인
- 도구가 없거나 부적절한 경우: 에이전트가 도구 사용을 억지로 하지 않고 올바르게 사용을 자제하는지 확인

즉, 이러한 지표에서 성공하기위해서는 에이전트가 적절한 도구를 선택하고, 정확한 매개변수 제공하며, 여러 도구를 효과적으로 조율하고, 불필요한 도구 사용까지 자제해야합니다.




## 데이터셋 구성 📁

이 평가 프레임워크는 **BFCL, τ-bench, Xlam, ToolACE**의 신중하게 선별된 벤치마크 데이터셋을 사용합니다.
각 데이터셋은 에이전트의 특정 능력을 검증하도록 설계되었으며, 평가 차원을 이해하는 것은 **모델 평가와 실제 응용 개발** 모두에서 필수적입니다.

### 1️⃣ 단일 턴(Single-Turn) 능력

| 평가 항목    | 요약               | 설명                                                       | 데이터 셋                                |
| -------- | ---------------- | -------------------------------------------------------- | ------------------------------------ |
| 기본 도구 사용 | 도구 이해 및 기본 함수 호출 | 도구 문서를 이해하고 매개변수를 처리하며, 기본적인 함수 호출을 수행. 응답 형식과 에러 처리에 중점 | `[xlam_single_tool_single_call]`     |
| 도구 선택    | 올바른 도구 선택 능력     | 여러 도구 중 적합한 도구를 선택하고, 도구 문서 이해 및 적합성 판단                  | `[xlam_multiple_tool_single_call]`   |
| 병렬 실행    | 다중 도구 동시 조율      | 여러 도구를 동시에 조율하여 효율성을 확보                                  | `[xlam_multiple_tool_multiple_call]` |
| 도구 재사용   | 배치 및 반복 처리       | 배치 작업이나 매개변수 변형을 효율적으로 처리, 대량 처리 상황에서 중요                 | `[xlam_single_tool_multiple_call]`   |


### 2️⃣ 오류 처리 및 엣지 케이스

| 평가 항목     | 요약         | 설명                                                       | 데이터 셋                                            |
| --------- | ---------- | -------------------------------------------------------- | ------------------------------------------------ |
| 무관성 감지    | 요청 부적합 대응  | 도구 한계를 인식하고, 사용자의 요청과 맞지 않을 때 적절히 응답. 사용자 경험과 시스템 신뢰성 향상 | `[BFCL_v3_irrelevance]`                          |
| 누락된 도구 처리 | 도구 없을 때 대응 | 필요한 도구가 없을 때 우아하게 대응하고, 한계 설명 및 대체 제안                    | `[xlam_tool_miss, BFCL_v3_multi_turn_miss_func]` |


### 3️⃣ 맥락 관리 (Context Management)

| 평가 항목 | 요약                | 설명                                                   | 데이터 셋                                                 |
| ----- | ----------------- | ---------------------------------------------------- | ----------------------------------------------------- |
| 긴 맥락  | 문맥 유지 및 복잡한 지시 이해 | 긴 대화 내 문맥을 유지하고, 복잡한 지시를 이해. 복잡한 워크플로우와 장시간 상호작용에 중요 | `[tau_long_context, BFCL_v3_multi_turn_long_context]` |


### 4️⃣ 다중 턴(Multi-Turn) 상호작용

| 평가 항목   | 요약         | 설명                                          | 데이터 셋                                                                     |
| ------- | ---------- | ------------------------------------------- | ------------------------------------------------------------------------- |
| 기본 대화   | 다중 턴 문맥 유지 | 여러 턴에 걸쳐 함수 호출 수행 및 문맥 유지. 대화형 애플리케이션 필수 능력 | `[BFCL_v3_multi_turn_base_single_func_call, toolace_single_func_call]`    |
| 복합 상호작용 | 전반적 강건성 평가 | 여러 도전 요소를 결합하여 모델의 강건성과 복합 시나리오 처리 능력 평가    | `[BFCL_v3_multi_turn_base_multi_func_call, BFCL_v3_multi_turn_composite]` |


### 5️⃣ 매개변수 관리 (Parameter Management)

| 평가 항목    | 요약        | 설명                                   | 데이터 셋                             |
| -------- | --------- | ------------------------------------ | --------------------------------- |
| 누락된 매개변수 | 불완전 정보 처리 | 불완전한 정보 처리 및 사용자와 상호작용하여 필요한 매개변수 수집 | `[BFCL_v3_multi_turn_miss_param]` |


## AI 엔지니어를 위한 실용적 시사점 🛠️

우리의 평가 결과는 견고하고 효율적인 AI 에이전트 시스템을 구축할 때 고려해야 할 핵심 사항을 보여줍니다. 핵심 포인트를 나눠보면 다음과 같습니다.


### 1️⃣ 모델 선택과 성능
복합 작업에서 **0.85 이상**의 점수를 기록하는 고급 모델은 복잡한 워크플로우를 처리하는 데 중요합니다. 대부분의 모델은 기본적인 도구 작업은 잘 수행하지만, **병렬 작업**을 다룰 때는 전체 점수보다 **개별 태스크별 실행 성능**을 세밀히 살펴야 합니다.

### 2️⃣ 맥락 및 오류 관리
**맥락 요약(context summarization)** 전략은 긴 문맥 처리에 약한 모델에서 필수적입니다. **오류 처리 메커니즘**은 무관성 감지나 매개변수 처리에서 약점을 보이는 모델에 특히 중요합니다. 이 경우 **구조화된 워크플로우**를 구현해 매개변수 수집 과정을 보완하는 것이 좋습니다.


### 3️⃣ 안전성과 신뢰성
무관한 동작을 감지하지 못하는 모델을 위해 **도구 접근 제어**를 강화해야 합니다. 성능이 불안정한 모델은 **검증(validation) 계층**을 추가하여 신뢰성을 높일 수 있습니다. 또한, **오류 복구 시스템(error recovery system)**을 구축하는 것도 중요합니다.


### 4️⃣ 시스템 성능 최적화
각 모델의 **병렬 처리 및 긴 맥락 처리 능력**에 맞춰 워크플로우를 설계하세요. **배치 전략(batch strategy)**을 구현할 때는 모델의 **도구 재사용 능력**을 고려하는 것이 효율성 향상에 도움이 됩니다.

---

### 5️⃣ 현재 AI 모델의 수준
현재는 **상용(proprietary)** 모델이 전반적인 능력에서 우위를 점하고 있지만, **오픈소스 대안(open-source alternatives)** 또한 빠르게 발전하고 있습니다. 간단한 도구 상호작용은 대부분의 모델에서 안정적으로 작동하지만, **복잡한 다중 턴 상호작용**과 **긴 문맥 처리**는 여전히 도전 과제로 남아 있습니다.

이러한 다양한 성능 차이는 **특정 사용 사례에 맞는 모델 선택**이 중요함을 보여줍니다. 즉, 일반적인 성능 지표보다는 **실제 적용 맥락**에 기반해 모델을 선택해야 합니다.


우리는 이 정보가 도움이 되길 바라며, LinkedIn, Twitter, 그리고 GitHub에서 여러분의 의견을 기다리고 있습니다.


## 인용 📄

아래 방식으로 리더보드를 인용할 수 있습니다:

```bibtex
@misc{agent-leaderboard,
  author = {Pratik Bhavsar},
  title = {Agent Leaderboard},
  year = {2025},
  publisher = {Galileo.ai},
  howpublished = "\url{https://huggingface.co/spaces/galileo-ai/agent-leaderboard}"
}
```

## 모델 성능에 대한 추가 인사이트 📈


### 추론 모델 (Reasoning Models)

우리의 분석에서 주목할 만한 점은 **추론 중심(reasoning-focused)** 모델들이었습니다. **o1**과 **o3-mini**는 각각 **0.876**과 **0.847**의 성능으로 함수 호출(Function Calling) 기능을 매우 훌륭하게 통합한 것으로 나타났습니다. 그러나 다른 추론 모델들에서는 상당한 어려움을 발견했습니다. 특히 **DeepSeek V3**와 **DeepSeek R1**은 전반적인 성능이 매우 뛰어남에도 불구하고, **함수 호출 기능 지원의 한계로 인해 리더보드에서 제외**되었습니다.

이 결정은 모델의 품질이 낮아서가 아니라, 두 모델 모두 공식 문서에서 현재 릴리즈 버전에서는 **함수 호출을 지원하지 않는다**고 명확히 명시하고 있습니다. 우리는 억지로 우회 기능을 구현하거나 오해의 소지가 있는 지표를 공개하기보다는, 함수 호출이 기본적으로 지원되는 향후 출시를 기다리기로 결정했습니다.

이 경험은 **함수 호출(function calling)**이 모든 고성능 언어 모델에 자동으로 포함된 일반 기능이 아니라, **명시적으로 설계되고 학습되어야 하는 특수 기능**임을 보여줍니다. 즉, 뛰어난 추론 능력을 가진 모델이라 하더라도, 구조적 함수 호출을 수행하려면 해당 기능에 대한 **명시적 설계와 학습**이 필요합니다. 따라서 모델을 선택하기 전에 **자신의 사용 사례(use case)**에 맞게 모델을 직접 평가하는 것이 가장 바람직합니다.


### 1️⃣ 엘리트 티어 (Elite Tier, ≥0.9)

- **특징**: 높은 성능과 안정적 일관성, 특히 복합 작업과 무관 정보 감지 강점
- **가격 대비 성능**: Gemini-2.0-flash가 우수

| 모델               | 평균 점수 | 강점                          | 가격($/백만 토큰) |
| ---------------- | ----- | --------------------------- | ----------- |
| Gemini-2.0-flash | 0.938 | 복합 시나리오 0.95, 무관 정보 감지 0.98 | 0.15/0.6    |
| GPT-4o           | 0.900 | 다중 도구 처리 0.99, 병렬 실행 0.98   | 2.5/10      |



### 2️⃣ 고성능 세그먼트 (High Performance, 0.85~0.9)
- **특징**: 함수 호출, 복합 시나리오, 장기 맥락 처리에서 강점

| 모델               | 평균 점수 | 강점                         | 가격($/백만 토큰) |
| ---------------- | ----- | -------------------------- | ----------- |
| Gemini-1.5-flash | 0.895 | 무관 정보 감지 0.98, 단일 함수 0.99  | -           |
| Gemini-1.5-pro   | 0.885 | 복합 작업 0.93, 단일 도구 0.99     | 1.25/5      |
| o1               | 0.876 | 장기 대화 맥락 0.98              | 15/60       |
| o3-mini          | 0.847 | 단일 함수 0.975, 무관 정보 감지 0.97 | 1.1/4.4     |



### 3️⃣ 중간 티어 (Mid Tier, 0.8~0.85)
- **특징**: 병렬 도구 사용 및 도구 선택에서 우수, 일부 모델은 장기 맥락이나 복합 작업에서 제한

| 모델                 | 평균 점수 | 강점                         | 약점         |
| ------------------ | ----- | -------------------------- | ---------- |
| GPT-4o-mini        | 0.832 | 병렬 도구 사용 0.99, 도구 선택       | 장기 맥락 0.51 |
| mistral-small-2501 | 0.832 | 장기 맥락 0.92, 도구 선택 0.99     | -          |
| Qwen-72b           | 0.817 | 무관 정보 감지 0.99, 장기 맥락 0.92  | -          |
| Mistral-large      | -     | 도구 선택 0.97                 | 복합 작업 0.76 |
| Claude-sonnet      | 0.801 | 도구 누락 감지 0.92, 단일 함수 0.955 | -          |



### 4️⃣ 기본 티어 (Base Tier, <0.8)
- **특징**: 특정 영역에서 효율적, 전체 평균 점수는 낮음

| 모델            | 평균 점수 | 강점         | 가격($/백만 토큰) |
| ------------- | ----- | ---------- | ----------- |
| Claude-haiku  | 0.765 | 균형 잡힌 성능   | 0.8/4       |
| Llama-70B     | 0.774 | 다중 도구 0.99 | -           |
| Mistral-small | 0.750 | 기본 작업 효율적  | -           |
| Ministral-8b  | 0.689 | -          | -           |
| Mistral-nemo  | 0.661 | -          | -           |



## 감사의 글 🙏

이 평가 프레임워크를 가능하게 한 벤치마크 데이터셋 제작자분들께 진심으로 감사를 드립니다.

- **BFCL** — 함수 호출 능력을 종합적으로 평가할 수 있는 데이터셋을 만든 Berkeley AI Research팀에 감사드립니다.
- **τ-bench** — 실제 도구 사용 시나리오에 초점을 맞춘 벤치마크를 개발한 Sierra Research 팀에 감사드립니다.
- **xLAM** — 21개 도메인에 걸친 방대한 Large Action Model*데이터셋을 구축한 Salesforce AI Research 팀에 감사드립니다.
- **ToolACE** — 390개 이상의 도메인을 포괄하는**API 상호작용 데이터셋을 개발한 ToolACE 팀에 감사드립니다.

이 데이터셋들은 언어 모델의 도구 호출 능력을 평가하기 위한 포괄적이고 체계적인 평가 프레임워크를 구축하는 데 핵심적인 역할을 했습니다.

